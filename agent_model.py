# -*- coding: utf-8 -*-
"""Proyecto_CC4.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1eYAoWTls03O9-YqtDaRp18URNwA-QK35

## Cancer Self-Remission and Tumor Stability
"""

import numpy as np
from abc import ABC
import matplotlib.pyplot as roberplot

# %matplotlib inline

# Base cell class
class Cell(ABC):
    def __init__(self, pos=0):
        self.pos = pos
        self.state = 0 # Active

    def plot(self, N, ax):
        x = 2*self.radius*(self.pos%N + ((self.pos//N)%2)/2)
        y = (self.pos//N)*np.sqrt(3)*self.radius
        circle = roberplot.Circle((x,y), self.radius, color=self.colors[self.state], fill=False, lw=1.0, clip_on=False)
        ax.add_artist(circle)

# Tumor cell class

class TumorCell(Cell):
    radius = 2.0
    colors = ["red", "black"]
  
    def __init__(self, pos, parent):
        super().__init__(pos)
        self.parent = parent
  
    def reproduce(self, tissue, nm):
        nm += self.pos
        if tissue.boundary != "rigid":
            nm[nm < 0] = nm[nm < 0]%tissue.tumor.size
            nm[nm >= tissue.tumor.size] = nm[nm >= tissue.tumor.size]%np.sqrt(tissue.tumor.size)
        else:
            nm[nm < 0] = self.pos
            nm[nm >= tissue.tumor.size] = self.pos
        mask = (tissue.tumor[nm] == None)*tissue.gm
        if not np.any(mask):
            return None
        new_pos = nm[np.argmax(np.random.rand(mask.size)*mask)]
        # Create cell 
        return TumorCell(new_pos, self.pos)

# T cell class

class TCell(Cell):
    radius = 1.0
    color = "red"

    def __init__(self, pos):
        super().__init__(pos)
    
    def move(self):
        return

# Tissue (grid) class
class Tissue():
    def __init__(self, N=10, init=0, boundary="rigid"):
        self.N = N # Lattice row size
        self.gm = np.random.choice([0.1,0.1,0.3,0.3,0.05,0.05], size=6, replace=False) # Irrigation gradient mask
        self.boundary = boundary
        self.tumor = np.empty(self.N**2, dtype=object) # Equilateral triangle lattice
        self.tumor[init] = TumorCell(init, -1)
        self.history = [self.tumor.copy()]
  
    # Returns the neighbors mask for a given cell with periodic boundary conditions.
    def get_nm_periodic(self, i):
        if (i%self.N == 0):
            if((i//self.N)%2 == 0):
                nm = [1, self.N, 2*self.N-1, self.N-1, -1, -self.N]
            else:
                nm = [1, self.N+1, self.N, self.N-1, -self.N, -self.N+1]
        elif (i%self.N == self.N-1):
            if(((i+1)//self.N)%2 == 0):
                nm = [-self.N+1, 1, self.N, -1, -self.N, -2*self.N+1]
            else:
                nm = [-self.N+1, self.N, self.N-1, -1, -self.N-1, -self.N]
        else:
            if((i//self.N)%2 == 0):
                nm = [1, self.N, self.N-1, -1, -self.N-1, -self.N]
            else:
                nm = [1, self.N+1, self.N, -1, -self.N, -self.N+1]
        return np.array(nm)

    # Returns the neighbors mask for a given cell with periodic boundary conditions.
    def get_nm_rigid(self, i):
        if (i%self.N == 0):
            if((i//self.N)%2 == 0):
                nm = [1, self.N, 0, 0, 0, -self.N]
            else:
                nm = [1, self.N+1, self.N, 0, -self.N, -self.N+1]
        elif (i%self.N == self.N-1):
            if(((i+1)//self.N)%2 == 0):
                nm = [0, 0, self.N, -1, -self.N, 0]
            else:
                nm = [0, self.N, self.N-1, -1, -self.N-1, -self.N]
        else:
            if((i//self.N)%2 == 0):
                nm = [1, self.N, self.N-1, -1, -self.N-1, -self.N]
            else:
                nm = [1, self.N+1, self.N, -1, -self.N, -self.N+1]
        return np.array(nm)

    def tumor_centroid(self, timestep=-1):
        mx = (self.history[timestep] != None).reshape(self.N, self.N)
        x, y = np.meshgrid(np.arange(self.N), np.arange(self.N))
        xm = x[mx==1].mean()
        ym = y[mx==1].mean()
        pos = np.round(xm) + self.N*np.round(ym)
        return int(pos)

    def timestep(self):
        self.cancer_growth()
        t = self.cancer_necrosis()
        #print(t.reshape(self.N,self.N))
        self.history.append(self.tumor.copy())
    
    def cancer_necrosis(self):
        counter = 0
        gg = (self.tumor.copy() == None)*100.0
        gg2 = self.tumor.copy()
        size = np.sum(self.tumor != None)
        while(size !=0):
            for cell in self.tumor[gg2 != None]:
                if self.boundary == "rigid":
                    nm = self.get_nm_rigid(cell.pos)
                    nm += cell.pos
                    nm[nm < 0] = nm[nm <0 ]%self.tumor.size
                    nm[nm >= self.tumor.size] = nm[nm >= self.tumor.size]%np.sqrt(self.tumor.size)
                else:
                    nm = self.get_nm_periodic
                    nm += cell.pos
                    nm[nm < 0]=cell.pos
                    nm[nm >= self.tumor.size] = cell.pos
                mask = (gg2[nm] == None)
                if np.sum(mask) >0:
                    #print(gg[nm])
                    if 100 in gg[nm]:
                        gg[cell.pos] = 95
                    if 100 not in gg[nm]:         
                        gg[cell.pos] = np.sum(gg[nm])/np.sum(gg[nm]!=0) - 5
                        #print(gg[cell.pos])
                    #gg2[cell.pos] = None
                    #size += -1
                    #if gg[cell.pos] <0:
                    #    gg[cell.pos] = 1
                    #if gg[cell.pos]<=5:
                    #    cell.state = 1
            for cell in self.tumor[gg2 != None]:
                if self.boundary == "rigid":
                    nm = self.get_nm_rigid(cell.pos)
                    nm += cell.pos
                    nm[nm < 0] = nm[nm <0 ]%self.tumor.size
                    nm[nm >= self.tumor.size] = nm[nm >= self.tumor.size]%np.sqrt(self.tumor.size)
                else:
                    nm = self.get_nm_periodic
                    nm += cell.pos
                    nm[nm < 0]=cell.pos
                    nm[nm >= self.tumor.size] = cell.pos
                mask = (gg2[nm] == None)
                if np.sum(mask) >0 and gg[cell.pos] != 0:
                    #gg[cell.pos] = np.sum(gg[nm])/np.sum(gg[nm]!=0) - 5
                    gg2[cell.pos] = None
                    size += -1
                    if gg[cell.pos] <0:
                        gg[cell.pos] = 1
                    if gg[cell.pos]<=5:
                        cell.state = 1
                #print(size)
                if size == self.N**2:
                    break
            if size == self.N**2:
                break
                #if np.sum(mask) == 0 and gg[cell.pos] == 0:
                #    gg[cell.pos] = np.mean(gg[nm])
                #    if np.mean(gg[nm]) != 0:
                #        size += -1
                #    if gg[cell.pos] <= 5:
                #        cell.state = 1
        return(gg)

    def cancer_growth(self):
        for cell in self.tumor[self.tumor != None]:
            new_cell = None
            if self.boundary=="rigid":
                nm = self.get_nm_rigid(cell.pos)
            else:
                nm = self.get_nm_periodic(cell.pos)
            if cell.state == 0:
                new_cell = cell.reproduce(self, nm)
            if new_cell != None:
                self.tumor[new_cell.pos] = new_cell
  
    def plot_tumor(self, timestep=-1):
        fig, ax = roberplot.subplots(1)
        fig.set_size_inches(8,7.5)
        ax.set_xlim(-2, (self.N+2)*TumorCell.radius*2)
        ax.set_ylim(-2, (self.N+2)*TumorCell.radius*np.sqrt(3))
        for cell in self.history[timestep][self.history[timestep] != None]:
            cell.plot(self.N, ax)
            continue
        pos = self.tumor_centroid(timestep)
        x = 2*TumorCell.radius*(pos%self.N + ((pos//self.N)%2)/2)
        y = (pos//self.N)*np.sqrt(3)*TumorCell.radius
        circle = roberplot.Circle((x,y), TumorCell.radius, color="orange", fill=True, lw=1.0, clip_on=False)
        ax.add_artist(circle)
        ax.set_xlabel("x")
        ax.set_ylabel("y")
        ax.set_title("Cancerous tissue on timestep " + str(timestep))


